# Labweek13 系统详细设计说明书

姓名|学号|版本管理员
--|:--:|--:
何青阳|19335055|√
贺雅迪|19335058|
曾嘉乐|19335009|

## 编写目的
- 为开发成员和客户之间提供共同的协议创力基础，对web服务器开发作功能描述  
- 对被开发软件的性能进行完整描述，为软件开发者进行详细设计和编程提供基础  
- 使甲方代表更深入地了解此系统，减少彼此之间交流困难以及开发过程中因需求不明确而产生的不必要的麻烦  
## 项目背景

因特网（Internet）是一个全球性的计算机互联网络，因特网上具有大量的技术资料数据库，其信息媒体包括数据、图像、文字、声音、视频等多种形式，信息属性有数据、交换软件、图书、档案等等。信息内容涉及通信、天文、医疗、政府机关、娱乐等各个方面。

万维网（WWW，也可简称为web）是因特网的一部分，它是一种建立在因特网上的全球性的、交互的、动态的分布式的信息系统，是一种建立在因特网上的网络服务。它的最基本概念就是超文本传输。

网络技术是当前计算机领域的的热门方向之一，在日常生活中，网络为我们的学习、工作、娱乐提供了极大的便利条件，在信息时代，网络编程对程序员来说是一项非常重要的技能。

## 定义

单例模式：程序在设计上必须保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

懒汉模式：单例模式下，全局的单例实例在第一次被使用时构建。

信号量：一种专门用于提供不同进程间或线程间同步手段的原语，用于解决互斥与同步问题。

条件变量：管程阻塞原因被设置为条件变量，每个条件变量维护一个等待队列。

互斥锁：用于保护临界区，以保护任何时刻只有一个线程在执行其中的代码。

## 参考资料
GB/T 9385-2008计算机软件需求规格说明规范  
IEEE Std. 830-1998-IEEE Recommended Practice for Software  

## 程序系统的组织结构

### 锁（lock）设计说明

#### 程序描述

在这部分进行了互斥锁、条件变量、信号量的实现。

#### 功能

- 互斥锁部分进行对pthread_mutex的相关函数的调用，目的是提高程序的可读性和简洁度
- 信号量部分负责对信号量的初始化、PV操作
- 条件变量部分负责对条件变量的初始化、PV操作

#### 输入项

条件变量P操作时对应pthread_cond_wait函数的输入：即传入互斥锁，把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上。


#### 输出项

无

#### 算法

无


#### 流程逻辑

与信号量、条件变量、互斥锁在pthread中的实现逻辑一致。

#### 接口

构造函数、析构函数、P（wait）V（signal）操作函数。

#### 存储分配

无

#### 注释设计

在对应封装类的首部对各个成员变量进行了注释，在成员函数实现部分的上方进行了注释。

#### 限制条件

无

#### 测试计划


在调用互斥锁时需要测试确保临界区最多只有一个线程在访问。

在调用信号量时需要测试确保可用资源数量与信号量的值一致。

在其他模块部分的实现前完成实现和测试，此部分由编写该程序的人员负责。


#### 尚未解决的问题

无


### 数据库连接池（sql_pool）设计说明

#### 程序描述

一个数据库连接资源的集合，在服务器启动时被创建，并初始化和分配资源。

#### 功能

- 创建多个数据库连接，当系统需要访问数据库时，如果有资源则分配给系统
- 回收数据库连接，当系统断开后，将连接回收到连接池
- 销毁数据库连接池


#### 输入项

初始化时：

输入项名|输入项类型
--|:--
url|string
username|string
pwd|string
databasename|string
port|int


释放连接时：

输入项名|输入项类型
--|:--
connList|MYSQL*



#### 输出项

初始化时：

返回布尔值：是否成功初始化

请求连接时：

返回可用连接：connection(MYSQL)

#### 算法

采用单例模式下的懒汉模式。即只有在需要的时候才进行实例化，且一个类只有一个实例。

#### 流程逻辑

服务器启动时，立即创建数据库连接池，自定义最大连接数。当需要进行数据库连接时，信号量减一，从连接池中获取一个连接，并进行相应的检索。完成后释放连接，信号量加一，连接被放回连接池。程序结束时，数据库连接池实例被销毁，此时资源也自动被完全释放。

#### 接口

此部分程序不能直接调用获取和释放连接的接口，而是通过初始化服务器、终止服务器的方式自动获取和释放连接。

#### 存储分配

数据库连接池在main函数栈帧分配。

#### 注释设计

在对应封装类的首部对各个成员变量进行了注释，在成员函数实现部分的上方进行了注释。

#### 限制条件

无

#### 测试计划

对初始化功能的测试：

输输入对应的输入项时，预期结果：可以得到初始化成功的返回值。

请求连接时，预期结果：返回需要数据库表的信息。

在http模块部分的实现前完成实现和测试，此部分由编写该程序的人员负责。


#### 尚未解决的问题

无

### http连接设计说明

#### 程序描述
一个http连接实例，维护并管理服务器与一特定用户之间的http连接。

#### 功能

- http连接的初始化，并与服务器线程池联系。
- 进行用户身份认证。
- 解析来自用户的http请求（元数据与业务逻辑数据），根据请求进行合适的应答。
- 检测连接异常状态并报告错误。

#### 输入项
初始化：
输入项名|输入项类型|描述
--|:--|:--
sockfd|int|套接字文件描述符
addr|sockaddr_in &|套接字地址结构

读取数据库数据：
输入项名|输入项类型|描述
--|:--|:--
connPool|connection_pool *|数据库连接池

#### 输出项
读取数据库连接、读取用户请求、生成应答文件、做出应答等函数，返回布尔值，标识过程是否成功。 


#### 算法
无

#### 流程逻辑
单个链接的工作行为由主程序控制。
初始化：从主程序获取套接字描述符与地址，将套接字加入线程监测池，更新连接数量。初始化各连接控制变量及数据库连接池。
关闭连接：将线程从线程池中移除，更新连接数量，关闭数据库连接。
读取客户数据：循环读取客户数据，直到无数据可读或对方关闭连接。
解析http请求：遍历请求文本，获得请求方法，目标url及http版本号。
完成请求：判断用户请求种类，根据请求种类调用处理不同请求的子函数。

#### 接口

与线程池：http连接在初始化时需要提供套接字描述符，在初始化过程中将该套接字加入线程池监听队列中。
与数据库连接池：http连接内维护一个数据库连接池实例，可以通过该实例建立与数据库的连接
与主函数：主函数通过一系列公共函数操作http连接的行为。

#### 存储分配

数据库连接池在main函数栈帧分配。

#### 注释设计

在对应封装类的首部对各个成员变量进行了注释，在成员函数实现部分的上方进行了注释。

#### 限制条件

无

#### 测试计划

对初始化功能的测试，包括各连接控制变量，静态变量的初始化；与线程池、数据库连接池的连接等。

对销毁功能的测试：检查对应的数据库连接、线程对应的套接字描述符是否正确回收，静态变量是否正常更新。

对于用户请求，能否正确解析http连接的含义并选择正确的应答方式。

对于主函数的功能调用，能否完成指定功能。

连接出现异常状态时，能否正确报告错误信息并做好数据保护。



#### 尚未解决的问题

无

### 线程池（threadpool）设计说明
### 程序描述
此部分目标为构造一个半同步半反应堆线程池。空间换时间,浪费服务器的硬件资源,换取运行效率。池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源。当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源。
#### 功能

使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
> * 同步I/O模拟proactor模式
> * 半同步/半反应堆
> * 线程池

#### 输入项
向请求队列中插入任务请求bool append(T* request);
锁机制中的输入项 
#### 输出项
pthread_create函数中
pthread_t *thread_tid 返回新生成的线程的id
插入任务请求时返回布尔值查看是否成功
#### 算法
无
#### 流程逻辑
使用同步I/O模拟实现Proactor事件处理模式。
同步I/O模型的工作流程如下：
> * （epoll_wait为例）：主线程往epoll内核事件表注册socket上的读就绪事件。
> * 主线程调用epoll_wait等待socket上有数据可读当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
>  * 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
>  * 主线程调用epoll_wait等待socket可写。
>  * 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

#### 接口

构造函数、析构函数以及互斥锁当中的接口

#### 存储分配
采用静态成员变量，在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。
#### 注释设计
在对应封装类的首部对各个成员变量进行了注释，在成员函数实现部分的上方进行了注释。
#### 限制条件
无
#### 测试计划
确认各个报错情况的处理是否合理（如线程数以及等待数的不合理取值）

在其他模块部分的实现前完成实现和测试，此部分由编写该程序的人员负责。
#### 尚未解决的问题
无




### 计时器（timer）设计说明
#### 程序描述

由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务。

#### 功能

> * 统一事件源
> * 基于升序链表的定时器
> * 处理非活动连接


#### 输入项
sockfd：int型
alarm: int型
sig_handler函数将信号值从管道写端写入，传输字符类型，而非整型
#### 输出项
sigaction函数返回值
0 表示成功，-1 表示有错误发生。

socketpair函数创建一对套接字进行通信，项目中使用管道通信，返回结果 0为创建成功，-1为创建失败。

timeout布尔值判断是否超时。
#### 算法
无
#### 流程逻辑

本项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。
#### 接口
构造函数、析构函数
API：sigaction结构体、
sigaction函数、
sigfillset函数、
SIGALRM、SIGTERM信号、
alarm函数、
socketpair函数、
send函数
#### 存储分配
采用链表指针存储
#### 注释设计

在对应封装类的首部对各个成员变量进行了注释，在成员函数实现部分的上方进行了注释。

#### 限制条件
无
#### 测试计划
确认各个报错情况的处理是否合理（如等待时间超时）。

查看函数操作对链表连接顺序的调整是否正确。

在其他模块部分的实现前完成实现和测试，此部分由编写该程序的人员负责。
#### 尚未解决的问题
无



